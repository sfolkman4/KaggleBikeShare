set_mode("regression") %>%
fit(log(count) ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data)
## Generate Predictions Using Linear Model
bike_predictions <- predict(my_linear_model,
new_data=test_data) # Use fit to predict
bike_predictions ## Look at the output
kaggle_submission <- bike_predictions %>%
bind_cols(test_data) %>%
select(datetime, .pred) %>%
rename(target = .pred) %>%
mutate(target = pmax(0, target)) %>%  # Ensure non-negative predictions
mutate(datetime = as.character(format(datetime)))  # Format datetime for submission
# Write the submission file
vroom_write(x = kaggle_submission, file = "./LinearPreds.csv", delim = ",")
# Ensure that the predictions are correctly formatted
kaggle_submission <- bike_predictions %>%
bind_cols(test_data) %>%                # Combine predictions with test data
select(datetime, .pred) %>%             # Select datetime and predicted values
rename(count = .pred) %>%               # Rename .pred to count
mutate(count = pmax(0, count)) %>%      # Ensure no negative predictions
mutate(datetime = as.character(datetime))  # Convert datetime to character for submission
# Write the submission file
vroom_write(x = kaggle_submission, file = "./LinearPreds.csv", delim = ",")
# Ensure that the predictions are correctly formatted
kaggle_submission <- bike_predictions %>%
# Ensure that the predictions are correctly formatted
kaggle_submission <- bike_predictions %>%
bind_cols(test_data) %>%                # Combine predictions with test data
select(datetime, .pred) %>%             # Select datetime and predicted values
rename(count = .pred) %>%               # Rename .pred to count
mutate(count = pmax(0, count)) %>%      # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Ensure that the predictions are correctly formatted
kaggle_submission <- bike_predictions %>%
bind_cols(test_data) %>%                # Combine predictions with test data
select(datetime, .pred) %>%             # Select datetime and predicted values
rename(count = .pred) %>%               # Rename .pred to count
mutate(count = pmax(0, count)) %>%      # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Write the submission file
vroom_write(x = kaggle_submission, file = "./LinearPreds.csv", delim = ",")
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "hour") %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
library(parsnip)
library(dplyr)
library(vroom)
library(ggplot2)
library(patchwork)
library(tidymodels)
library(parsnip)
library(poissonreg)
train_data <- vroom("C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/train.csv")
test_data <- vroom("C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/test.csv")
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "hour") %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
bike_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "hour") %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_mutate(hour = hour(datetime)) %>%  # Extract hour using lubridate
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
bike_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
bike_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Write the submission file
vroom_write(x = bike_predictions,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/LinearWorkflowPreds.csv",
delim = ",")
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_rm(casual, registered) %>%  # Remove 'casual' and 'registered' columns
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%  # Extract day of week
step_time(datetime, features = c("hour", "minute")) %>%  # Extract hour and minute
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%  # Log transform the target variable
step_normalize(all_numeric_predictors()) # Additional step: normalize numeric predictors
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
bike_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_rm(casual, registered) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%
step_normalize(all_numeric_predictors())
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
test_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Write the test predictions file
vroom_write(x = test_predictions,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
# Feature Engineering
bike_recipe <- recipe(log(count ~ ., data = train_data)) %>%
step_rm(casual, registered) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%
step_normalize(all_numeric_predictors())
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Feature Engineering
bike_recipe <- recipe(log(count ~ ., data = train_data)) %>%
step_rm(casual, registered) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%
step_normalize(all_numeric_predictors())
# Define the linear regression model
lin_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression")
# Combine into a Workflow and fit
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(lin_model) %>%
fit(data = train_data)
# Generate predictions on test data
test_predictions <- predict(bike_workflow, new_data = test_data) %>%
mutate(count = exp(.pred) - 1) %>%  # Back-transform from log scale
bind_cols(test_data) %>%
select(datetime, count) %>%
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))
# Write the test predictions file
vroom_write(x = test_predictions,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
#  Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_rm(casual, registered) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%
step_normalize(all_numeric_predictors())
# Prepare the data using the recipe
prepped_recipe <- prep(bike_recipe)
train_data_processed <- bake(prepped_recipe, new_data = train_data)
test_data_processed <- bake(prepped_recipe, new_data = test_data)
# Fit the linear model (using your original formula)
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(log(count) ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed,
data = train_data_processed)
# Generate Predictions Using Linear Model
bike_predictions <- predict(my_linear_model, new_data = test_data_processed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data) %>%        # Combine predictions with original test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Write the test predictions file
vroom_write(x = bike_predictions_original,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
train_data$season <- as.factor(train_data$season)
train_data$holiday <- as.factor(train_data$holiday)
train_data$workingday <- as.factor(train_data$workingday)
train_data$weather <- as.factor(train_data$weather)
test_data$season <- as.factor(test_data$season)
test_data$holiday <- as.factor(test_data$holiday)
test_data$workingday <- as.factor(test_data$workingday)
test_data$weather <- as.factor(test_data$weather)
test_data$hour <- as.numeric(format(test_data$datetime, "%H"))
test_data$day <- as.numeric(format(test_data$datetime, "%d"))
test_data$month <- as.numeric(format(test_data$datetime, "%m"))
train_data$hour <- as.numeric(format(train_data$datetime, "%H"))
train_data$day <- as.numeric(format(train_data$datetime, "%d"))
train_data$month <- as.numeric(format(train_data$datetime, "%m"))
# Step 1: Define a Recipe
bike_recipe <- recipe(count ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = as.factor(weather)) %>%
step_mutate(season = as.factor(season)) %>%
step_rm(datetime)  # Optionally remove datetime column
train_data
# Step 2: Define a Poisson Regression Model
pois_model <- poisson_reg() %>%
set_engine("glm") %>%
set_mode("regression")
# Step 3: Combine Recipe and Model into a Workflow
bike_workflow <- workflow() %>%
add_recipe(bike_recipe) %>%
add_model(pois_model)
# Step 4: Fit the Model (Poisson regression with log(count) as the response)
bike_fit <- fit(bike_workflow, data = train_data)
# Step 5: Make Predictions on Test Data
lin_preds <- predict(bike_workflow, new_data = test_data)
#  Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_rm(casual, registered) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_log(count, offset = 1) %>%
step_normalize(all_numeric_predictors())
# Prepare the data using the recipe
prepped_recipe <- prep(bike_recipe)
train_data_processed <- bake(prepped_recipe, new_data = train_data)
test_data_processed <- bake(prepped_recipe, new_data = test_data)
# Fit the linear model (using your original formula)
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(log(count) ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed,
data = train_data_processed)
# Generate Predictions Using Linear Model
bike_predictions <- predict(my_linear_model, new_data = test_data_processed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data) %>%        # Combine predictions with original test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
library(parsnip)
library(dplyr)
library(vroom)
library(ggplot2)
library(patchwork)
library(tidymodels)
library(parsnip)
library(poissonreg)
train_data <- vroom("C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/train.csv")
test_data <- vroom("C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/test.csv")
train_data <- train_data %>%
select(-casual, -registered)
# Step 2: Change 'count' to log(count) in train_data
train_data <- train_data %>%
mutate(count = log(count))
# Print the first few rows and structure of the cleaned train_data to verify changes
print(head(train_data))
print(str(train_data))
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_normalize(all_numeric_predictors())
# Fit the linear model
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data)
view(bike_recipe)
view(train_data)
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_normalize(all_numeric_predictors())
# Prepare the recipe using the training data
bike_recipe_prep <- prep(bike_recipe, training = train_data)
# Apply the recipe to the training data
train_data_transformed <- bake(bike_recipe_prep, new_data = train_data)
# Fit the linear model using the transformed training data
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data_transformed)
# Apply the recipe to the test data
test_data_transformed <- bake(bike_recipe_prep, new_data = test_data)
# Generate Predictions Using Linear Model on the transformed test data
bike_predictions <- predict(my_linear_model, new_data = test_data_transformed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data_transformed) %>%  # Combine predictions with transformed test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Write the test predictions file
vroom_write(x = bike_predictions_original,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = "dow") %>%
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_normalize(all_numeric_predictors())
# Prepare the recipe using the training data
bike_recipe_prep <- prep(bike_recipe, training = train_data)
# Apply the recipe to the training data
train_data_transformed <- bake(bike_recipe_prep, new_data = train_data)
# Check the transformed training data
print(colnames(train_data_transformed))  # Check for 'hour' and other features
# Fit the linear model using the transformed training data
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data_transformed)
# Fit the linear model using the transformed training data
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ datetime_hour + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data_transformed)
# Apply the recipe to the test data
test_data_transformed <- bake(bike_recipe_prep, new_data = test_data)
# Check the transformed test data
print(colnames(test_data_transformed))  # Check for 'hour' and other features
# Generate Predictions Using Linear Model on the transformed test data
bike_predictions <- predict(my_linear_model, new_data = test_data_transformed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data_transformed) %>%  # Combine predictions with transformed test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Write the test predictions file
vroom_write(x = bike_predictions_original,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = c("dow", "month")) %>%  # Extract month along with dow
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_normalize(all_numeric_predictors())
# Prepare the recipe using the training data
bike_recipe_prep <- prep(bike_recipe, training = train_data)
# Apply the recipe to the training data
train_data_transformed <- bake(bike_recipe_prep, new_data = train_data)
# Check the transformed training data
print(colnames(train_data_transformed))  # Check for 'hour' and other features
# Fit the linear model using the transformed training data
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ datetime_hour + datetime_dow + datetime_month + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data_transformed)
# Apply the recipe to the test data
test_data_transformed <- bake(bike_recipe_prep, new_data = test_data)
# Check the transformed test data
print(colnames(test_data_transformed))  # Check for 'hour' and other features
# Generate Predictions Using Linear Model on the transformed test data
bike_predictions <- predict(my_linear_model, new_data = test_data_transformed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data_transformed) %>%  # Combine predictions with transformed test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Feature Engineering
bike_recipe <- recipe(count ~ ., data = train_data) %>%
step_mutate(weather = ifelse(weather == 4, 3, weather)) %>%
step_mutate(weather = factor(weather)) %>%
step_date(datetime, features = c("dow", "month")) %>%  # Extract month along with dow
step_time(datetime, features = c("hour", "minute")) %>%
step_mutate(season = factor(season)) %>%
step_normalize(all_numeric_predictors()) %>%
step_zv(all_predictors())
# Prepare the recipe using the training data
bike_recipe_prep <- prep(bike_recipe, training = train_data)
# Apply the recipe to the training data
train_data_transformed <- bake(bike_recipe_prep, new_data = train_data)
# Check the transformed training data
print(colnames(train_data_transformed))  # Check for 'hour' and other features
# Fit the linear model using the transformed training data
my_linear_model <- linear_reg() %>%
set_engine("lm") %>%
set_mode("regression") %>%
fit(count ~ datetime_hour + datetime_dow + datetime_month + season + holiday + workingday + weather + temp + atemp + humidity + windspeed, data = train_data_transformed)
# Apply the recipe to the test data
test_data_transformed <- bake(bike_recipe_prep, new_data = test_data)
# Check the transformed test data
print(colnames(test_data_transformed))  # Check for 'hour' and other features
# Generate Predictions Using Linear Model on the transformed test data
bike_predictions <- predict(my_linear_model, new_data = test_data_transformed)
# Transform predictions from log scale to original scale
bike_predictions_original <- bike_predictions %>%
mutate(count = exp(.pred)) %>%  # Exponentiate the predictions to revert to the original scale
bind_cols(test_data_transformed) %>%  # Combine predictions with transformed test data
select(datetime, count) %>%     # Select datetime and predicted values
mutate(count = pmax(0, count)) %>%  # Ensure no negative predictions
mutate(datetime = as.character(format(datetime)))  # Convert datetime to character for submission
# Write the test predictions file
vroom_write(x = bike_predictions_original,
file = "C:/Users/sfolk/Desktop/STAT348/KaggleBikeShare/TestPredictions.csv",
delim = ",")
